---
interface Props {
  /** El rol del elemento anchor. */
  role?: 'anchor' | 'button';
  /** La variante visual del botón. */
  variant?: 'text' | 'platted';
  /** El color del botón. */
  action?: 'default' | 'neutral';
  /** El tamaño del ancla. */
  size?: 'small' | 'medium' | 'large';
  /** El ancho del botón.*/
  wide?: 'fit' | 'fill';
  /** Si el botón debe estar deshabilitado. */
  disabled?: boolean;
  /** El tipo de contenido. */
  label?: 'TextOnly' | 'IconOnly' | 'TextAndIcon';
  /** If 'Label' is set on 'TextAndIcon' then: */
  Icon?: 'before' | 'after';
  /** Clases CSS adicionales para personalizar. */
  class?: string;
  /** Atributos adicionales como `onclick`, `id`, `data-*`, etc. */
  [key: string]: any;
}

// 1. Desestructurar props con valores por defecto.
const {
  role = 'anchor',
  variant = 'text',
  action = 'default',
  size = 'medium',
  wide = 'fit',
  disabled = false,
  text,
  class: userClass,
  href,
  ...rest
} = Astro.props;

// 2. Atributos finales para el elemento (incluye el resto de props).
const attrs: Record<string, any> = {
  ...rest,
  role,
  disabled,
  'aria-disabled': disabled ? 'true' : undefined,
  tabindex: disabled ? -1 : undefined,
};

// 3. Comprobar si se están usando los slots para los símbolos.
const hasSymbol = Astro.slots.has('symbol');

// 4. Construir la lista de clases dinámicamente y la clase final.
const classList = [
  'anchor',
  `variant-${variant}`,
  `action-${action}`,
  `size-${size}`,
  `wide-${wide}`,
  userClass,
  hasSymbol && 'has-symbol',
].filter(Boolean);

const finalClass = classList.join(' ');

const pathname = Astro.url.pathname.replace(import.meta.env.BASE_URL, '');
const subpath = pathname.match(/[^\/]+/g);
const isActive = href === pathname || href === '/' + (subpath?.[0] || '');
---
<a href={href} class={finalClass} aria-current={isActive ? 'page' : undefined} {...attrs}>
  <slot />
</a>
<style>
  @layer components {
    :is(a, a[role="button"]).anchor {
      height: fit-content;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-family: var(--font-family-sans);
      font-weight: var(--font-weight-regular);
      text-align: center;
      backface-visibility: hidden;
      -webkit-font-smoothing: subpixel-antialiased;
      touch-action: manipulation;
      will-change: color, background-color, border-radius, transform;
      transition: color 150ms, background-color 150ms, border-radius 150ms, transform 150ms;
      transform: scale(1) translate3d(0px, 0px, 0px) perspective(1px);
      &.wide-fit {
        width: fit-content
      }
      &.wide-fill {
        width: 100%
      }
      &[aria-current="page"] {
        border-radius: 32px;
        color: var(--color-label-primary-active, oklch(0.99 0 0));
        background-color: var(--color-anchor-bg-active, oklch(0.22 0 0));
        cursor: default;
        pointer-events: none
      }
      @media (hover: hover) {
        &:hover {
          border-radius: 8px;
          transform: scale(1.03)
        }
      }
      &:active {
        border-radius: 4px;
        transform: scale(1.03)
      }
      &:focus-visible {
        outline: 2px solid var(--color-focus)
      }
      &.variant-text {
        
        &[aria-current="page"] {
          
        }
      }
      &.variant-platted {
        padding: 8px 10px;
        border-radius: 8px;
        background: var(--color-fill);
        color: var(--color-label-controls);
        &[aria-current="page"] {
          color: var(--color-label-primary);
          background-color: var(--color-anchor-bg-active)
        }
        @media (hover: hover) {
          &:hover {
            --color-anchor-hover: okchl(1 1 1 / 0.08);
            background-color: var(--color-anchor-hover)
          }
        }
      }
      &[role="button"] {
        border-radius: 32px
      }
      &[role="button"][aria-pressed="true"] {
        
      }
    }
  }
</style>